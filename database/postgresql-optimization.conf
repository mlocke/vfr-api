# =====================================================================================
# PostgreSQL Configuration for VFR API - Financial Data Workloads
# Optimized for high-frequency financial data processing and real-time analytics
# =====================================================================================

# =====================================================================================
# MEMORY CONFIGURATION
# =====================================================================================

# Adjust based on available system memory (recommended: 25% of total RAM)
shared_buffers = '2GB'                    # For 8GB RAM system, adjust proportionally

# Work memory for complex queries and sorting operations
work_mem = '128MB'                        # Increased for financial calculations

# Maintenance work memory for VACUUM, CREATE INDEX, etc.
maintenance_work_mem = '512MB'            # Higher for large table maintenance

# Effective cache size (should be ~75% of total RAM)
effective_cache_size = '6GB'              # Adjust based on system RAM

# Maximum memory for prepared statements
max_prepared_transactions = 100           # For transaction safety

# =====================================================================================
# CONNECTION AND CONCURRENCY
# =====================================================================================

# Maximum connections (balance with connection pooling)
max_connections = 200                     # Use PgBouncer for connection pooling

# Parallel query configuration for large analytical queries
max_parallel_workers = 8                  # Based on CPU cores
max_parallel_workers_per_gather = 4       # Parallel workers per query
max_parallel_maintenance_workers = 4      # For parallel maintenance operations

# Background writer for better write performance
bgwriter_delay = 200ms                    # Write frequency
bgwriter_lru_maxpages = 100              # Pages to write per round
bgwriter_lru_multiplier = 2.0            # Adaptive writing

# =====================================================================================
# STORAGE AND I/O OPTIMIZATION
# =====================================================================================

# Checkpoint configuration for write performance
checkpoint_timeout = '15min'             # Time between checkpoints
checkpoint_completion_target = 0.9       # Smooth checkpoint spreading
max_wal_size = '4GB'                     # WAL size before checkpoint
min_wal_size = '1GB'                     # Minimum WAL retention

# Random page cost (adjust for SSD vs HDD)
random_page_cost = 1.1                   # For SSD storage (default 4.0 for HDD)
seq_page_cost = 1.0                      # Sequential scan cost

# Effective I/O concurrency for storage
effective_io_concurrency = 200           # For SSD storage

# =====================================================================================
# QUERY PLANNING AND OPTIMIZATION
# =====================================================================================

# Cost-based optimizer settings
cpu_tuple_cost = 0.01                    # Cost of processing each row
cpu_index_tuple_cost = 0.005             # Cost of processing index entry
cpu_operator_cost = 0.0025               # Cost of processing each operator

# Statistics for query planning
default_statistics_target = 500          # Increased for better query plans
constraint_exclusion = partition         # Enable partition pruning

# Join and sorting optimization
join_collapse_limit = 8                  # Complex join optimization
from_collapse_limit = 8                  # FROM list optimization

# =====================================================================================
# FINANCIAL DATA SPECIFIC OPTIMIZATIONS
# =====================================================================================

# Time zone for financial markets (adjust as needed)
timezone = 'UTC'                         # Consistent timezone for global markets
log_timezone = 'UTC'

# Locale settings for numeric formatting
lc_monetary = 'en_US.UTF-8'
lc_numeric = 'en_US.UTF-8'

# Date style for financial reporting
datestyle = 'ISO, MDY'

# =====================================================================================
# LOGGING AND MONITORING
# =====================================================================================

# Logging configuration for monitoring and debugging
logging_collector = on
log_directory = 'pg_log'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
log_rotation_age = 1d
log_rotation_size = 100MB

# What to log
log_min_duration_statement = 1000        # Log slow queries (>1 second)
log_checkpoints = on                     # Log checkpoint activity
log_connections = on                     # Log connections
log_disconnections = on                  # Log disconnections
log_lock_waits = on                      # Log lock waits
log_temp_files = 10MB                    # Log large temp files

# Statement logging for audit
log_statement = 'ddl'                    # Log DDL statements
log_line_prefix = '%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h '

# Performance monitoring
track_activities = on
track_counts = on
track_io_timing = on                     # Track I/O timing
track_functions = all                    # Track function calls

# =====================================================================================
# SECURITY AND AUTHENTICATION
# =====================================================================================

# SSL configuration (enable for production)
ssl = off                                # Enable in production
ssl_cert_file = 'server.crt'
ssl_key_file = 'server.key'

# Authentication
password_encryption = scram-sha-256      # Strong password encryption

# Connection security
listen_addresses = 'localhost'          # Restrict to localhost for development
port = 5432

# Row Level Security
row_security = on                        # Enable RLS for multi-tenant data

# =====================================================================================
# REPLICATION AND HIGH AVAILABILITY
# =====================================================================================

# WAL configuration for replication (if needed)
wal_level = replica                      # Enable replication
max_wal_senders = 3                      # Number of replication connections
max_replication_slots = 3                # Replication slots

# Archive settings (for backup and recovery)
archive_mode = off                       # Enable for production backups
# archive_command = 'test ! -f /var/lib/postgresql/archive/%f && cp %p /var/lib/postgresql/archive/%f'

# =====================================================================================
# EXTENSIONS AND MODULES
# =====================================================================================

# Preload extensions for better performance
shared_preload_libraries = 'pg_stat_statements'

# pg_stat_statements configuration for query analysis
pg_stat_statements.max = 10000
pg_stat_statements.track = all
pg_stat_statements.track_utility = on
pg_stat_statements.save = on

# =====================================================================================
# VACUUM AND MAINTENANCE
# =====================================================================================

# Autovacuum configuration for financial data
autovacuum = on
autovacuum_max_workers = 6               # Increased for large tables
autovacuum_naptime = 30s                 # More frequent autovacuum
autovacuum_vacuum_threshold = 50         # Lower threshold for small tables
autovacuum_vacuum_scale_factor = 0.1     # More aggressive for high-update tables
autovacuum_analyze_threshold = 50
autovacuum_analyze_scale_factor = 0.05   # More frequent analysis

# Vacuum cost delay (balance maintenance with performance)
vacuum_cost_delay = 10ms
vacuum_cost_page_hit = 1
vacuum_cost_page_miss = 10
vacuum_cost_page_dirty = 20
vacuum_cost_limit = 2000

# =====================================================================================
# LOCK MANAGEMENT
# =====================================================================================

# Lock configuration for high-concurrency workloads
max_locks_per_transaction = 256          # Increased for complex transactions
max_pred_locks_per_transaction = 128     # For serializable transactions

# Deadlock detection
deadlock_timeout = 1s                    # Quick deadlock detection

# =====================================================================================
# SPECIALIZED FINANCIAL WORKLOAD SETTINGS
# =====================================================================================

# Enable JIT compilation for complex analytical queries
jit = on                                 # Just-in-time compilation
jit_above_cost = 100000                  # Enable JIT for expensive queries
jit_optimize_above_cost = 500000         # Aggressive optimization threshold

# Large object support for storing financial reports/documents
max_files_per_process = 1000

# Temp file management for large analytical queries
temp_file_limit = 10GB                   # Limit temp file usage

# =====================================================================================
# TIME-SERIES SPECIFIC OPTIMIZATIONS (if using TimescaleDB)
# =====================================================================================

# Uncomment these if using TimescaleDB extension
# timescaledb.max_background_workers = 8
# timescaledb.last_updated_threshold = '1 hour'
# timescaledb.telemetry_level = off

# =====================================================================================
# DEVELOPMENT VS PRODUCTION NOTES
# =====================================================================================

# DEVELOPMENT SETTINGS (current configuration):
# - Lower security for ease of development
# - More verbose logging
# - Smaller memory allocation
# - Local connections only

# FOR PRODUCTION, ADJUST:
# 1. Enable SSL/TLS (ssl = on)
# 2. Configure proper listen_addresses
# 3. Enable archive_mode for backups
# 4. Increase shared_buffers based on available RAM
# 5. Configure monitoring and alerting
# 6. Set up connection pooling with PgBouncer
# 7. Configure replication for high availability

# =====================================================================================
# MONITORING QUERIES
# =====================================================================================

# Use these queries to monitor performance:
#
# 1. Current activity:
# SELECT pid, usename, application_name, state, query FROM pg_stat_activity WHERE state = 'active';
#
# 2. Slow queries:
# SELECT query, mean_time, calls FROM pg_stat_statements ORDER BY mean_time DESC LIMIT 10;
#
# 3. Index usage:
# SELECT schemaname, tablename, indexname, idx_scan, idx_tup_read FROM pg_stat_user_indexes;
#
# 4. Table sizes:
# SELECT schemaname, tablename, pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename))
# FROM pg_tables WHERE schemaname = 'public' ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;

# =====================================================================================
# CONFIGURATION NOTES
# =====================================================================================

# This configuration is optimized for:
# - Real-time financial data processing
# - High-frequency insert/update operations
# - Complex analytical queries
# - Time-series data patterns
# - Multi-user concurrent access
# - Regulatory compliance requirements

# Adjust memory settings based on your system's available RAM
# Monitor performance and adjust as needed
# Always test configuration changes in development first