/**
 * Enhanced Sentiment Analysis Service
 * Multi-source sentiment aggregation and advanced sentiment analysis
 * Combines news, social media, analyst reports, and insider activity sentiment
 */

import { SentimentAnalysis, MultiSourceSentiment, SentimentSignal } from './types'
import { createServiceErrorHandler } from '../error-handling'
import SecurityValidator from '../security/SecurityValidator'
import { redisCache } from '../cache/RedisCache'

export class EnhancedSentimentAnalysisService {
  private readonly errorHandler: ReturnType<typeof createServiceErrorHandler>
  private readonly cacheTTL = 1800000 // 30 minutes cache for sentiment data

  constructor() {
    this.errorHandler = createServiceErrorHandler('EnhancedSentimentAnalysisService')
  }

  /**
   * Get sentiment analysis from a specific source
   * @param symbol Stock symbol
   * @param source Sentiment source (news, social, analyst, insider)
   * @returns Promise<SentimentAnalysis>
   */
  async getSentimentFromSource(symbol: string, source: 'news' | 'social' | 'analyst' | 'insider'): Promise<SentimentAnalysis> {
    try {
      SecurityValidator.validateSymbol(symbol)

      const cacheKey = `sentiment-source:${symbol.toUpperCase()}:${source}`
      const cachedData = await redisCache.get<SentimentAnalysis>(cacheKey)

      if (cachedData) {
        return cachedData
      }

      // Mock sentiment analysis from different sources
      const baseSentiment = this.generateMockSentiment(symbol, source)

      const sentiment: SentimentAnalysis = {
        symbol: symbol.toUpperCase(),
        sources: [
          {
            name: source,
            sentiment: baseSentiment,
            confidence: 0.8,
            weight: 1.0,
            lastUpdated: Date.now()
          }
        ],
        aggregatedSentiment: baseSentiment,
        sentimentCategory: this.categorizeSentiment(baseSentiment),
        volatility: Math.random() * 0.3 + 0.1, // 0.1-0.4
        trend: this.determineTrend(baseSentiment),
        confidence: 0.8,
        timestamp: Date.now(),
        source: 'EnhancedSentimentAnalysisService'
      }

      await redisCache.set(cacheKey, sentiment, this.cacheTTL)
      return sentiment

    } catch (error) {
      throw this.errorHandler.handleError('getSentimentFromSource', error, { symbol, source })
    }
  }

  /**
   * Get multi-source sentiment analysis
   * @param symbol Stock symbol
   * @returns Promise<MultiSourceSentiment>
   */
  async getMultiSourceSentiment(symbol: string): Promise<MultiSourceSentiment> {
    try {
      SecurityValidator.validateSymbol(symbol)

      const cacheKey = `multi-sentiment:${symbol.toUpperCase()}`
      const cachedData = await redisCache.get<MultiSourceSentiment>(cacheKey)

      if (cachedData) {
        return cachedData
      }

      // Get sentiment from all sources
      const [news, social, analyst, insider] = await Promise.allSettled([
        this.getSentimentFromSource(symbol, 'news'),
        this.getSentimentFromSource(symbol, 'social'),
        this.getSentimentFromSource(symbol, 'analyst'),
        this.getSentimentFromSource(symbol, 'insider')
      ])

      const getResult = (result: PromiseSettledResult<SentimentAnalysis>) =>
        result.status === 'fulfilled' ? result.value : this.createDefaultSentiment(symbol)

      const newsResult = getResult(news)
      const socialResult = getResult(social)
      const analystResult = getResult(analyst)
      const insiderResult = getResult(insider)

      // Calculate composite score with weights
      const weights = { news: 0.3, social: 0.2, analyst: 0.3, insider: 0.2 }
      const compositeScore =
        newsResult.aggregatedSentiment * weights.news +
        socialResult.aggregatedSentiment * weights.social +
        analystResult.aggregatedSentiment * weights.analyst +
        insiderResult.aggregatedSentiment * weights.insider

      const multiSourceSentiment: MultiSourceSentiment = {
        symbol: symbol.toUpperCase(),
        news: newsResult,
        social: socialResult,
        analyst: analystResult,
        insider: insiderResult,
        composite: {
          score: compositeScore,
          confidence: 0.85,
          category: this.categorizeSentiment(compositeScore)
        },
        timestamp: Date.now(),
        source: 'EnhancedSentimentAnalysisService'
      }

      await redisCache.set(cacheKey, multiSourceSentiment, this.cacheTTL)
      return multiSourceSentiment

    } catch (error) {
      throw this.errorHandler.handleError('getMultiSourceSentiment', error, { symbol })
    }
  }

  /**
   * Generate sentiment-based trading signal
   * @param symbol Stock symbol
   * @returns Promise<SentimentSignal>
   */
  async getSentimentSignal(symbol: string): Promise<SentimentSignal> {
    try {
      SecurityValidator.validateSymbol(symbol)

      const cacheKey = `sentiment-signal:${symbol.toUpperCase()}`
      const cachedData = await redisCache.get<SentimentSignal>(cacheKey)

      if (cachedData) {
        return cachedData
      }

      const sentiment = await this.getMultiSourceSentiment(symbol)
      const score = sentiment.composite.score

      let signal: 'BUY' | 'SELL' | 'HOLD' = 'HOLD'
      let strength: 'WEAK' | 'MODERATE' | 'STRONG' = 'WEAK'

      if (score > 0.3) {
        signal = 'BUY'
        strength = score > 0.6 ? 'STRONG' : 'MODERATE'
      } else if (score < -0.3) {
        signal = 'SELL'
        strength = score < -0.6 ? 'STRONG' : 'MODERATE'
      }

      const reasoning: string[] = [
        `Composite sentiment score: ${score.toFixed(2)}`,
        `News sentiment: ${sentiment.news.aggregatedSentiment.toFixed(2)}`,
        `Social sentiment: ${sentiment.social.aggregatedSentiment.toFixed(2)}`,
        `Analyst sentiment: ${sentiment.analyst.aggregatedSentiment.toFixed(2)}`,
        `Insider sentiment: ${sentiment.insider.aggregatedSentiment.toFixed(2)}`
      ]

      const sentimentSignal: SentimentSignal = {
        symbol: symbol.toUpperCase(),
        signal,
        strength,
        sentiment,
        reasoning,
        confidence: sentiment.composite.confidence,
        timestamp: Date.now(),
        source: 'EnhancedSentimentAnalysisService'
      }

      await redisCache.set(cacheKey, sentimentSignal, this.cacheTTL)
      return sentimentSignal

    } catch (error) {
      throw this.errorHandler.handleError('getSentimentSignal', error, { symbol })
    }
  }

  /**
   * Get sentiment signals for multiple symbols
   * @param symbols Array of stock symbols
   * @returns Promise<SentimentSignal[]>
   */
  async getSentimentSignalBatch(symbols: string[]): Promise<SentimentSignal[]> {
    try {
      if (!symbols || symbols.length === 0) {
        throw new Error('Symbols array is required')
      }

      const results = await Promise.allSettled(
        symbols.map(symbol => this.getSentimentSignal(symbol))
      )

      return results
        .filter((result): result is PromiseFulfilledResult<SentimentSignal> => result.status === 'fulfilled')
        .map(result => result.value)

    } catch (error) {
      throw this.errorHandler.handleError('getSentimentSignalBatch', error, { symbols })
    }
  }

  /**
   * Generate mock sentiment based on symbol and source
   * @private
   */
  private generateMockSentiment(symbol: string, source: string): number {
    // Generate consistent but varied sentiment based on symbol hash
    const hash = symbol.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0)
    const sourceMultiplier = { news: 1.0, social: 0.8, analyst: 1.2, insider: 0.9 }[source] || 1.0

    const baseSentiment = Math.sin(hash / 100) * sourceMultiplier
    return Math.max(-1, Math.min(1, baseSentiment))
  }

  /**
   * Categorize sentiment score into category
   * @private
   */
  private categorizeSentiment(score: number): 'VERY_POSITIVE' | 'POSITIVE' | 'NEUTRAL' | 'NEGATIVE' | 'VERY_NEGATIVE' {
    if (score > 0.6) return 'VERY_POSITIVE'
    if (score > 0.2) return 'POSITIVE'
    if (score > -0.2) return 'NEUTRAL'
    if (score > -0.6) return 'NEGATIVE'
    return 'VERY_NEGATIVE'
  }

  /**
   * Determine sentiment trend
   * @private
   */
  private determineTrend(score: number): 'IMPROVING' | 'DECLINING' | 'STABLE' {
    // Mock trend determination
    if (score > 0.1) return 'IMPROVING'
    if (score < -0.1) return 'DECLINING'
    return 'STABLE'
  }

  /**
   * Create default sentiment for fallback
   * @private
   */
  private createDefaultSentiment(symbol: string): SentimentAnalysis {
    return {
      symbol: symbol.toUpperCase(),
      sources: [{
        name: 'default',
        sentiment: 0,
        confidence: 0.1,
        weight: 1.0,
        lastUpdated: Date.now()
      }],
      aggregatedSentiment: 0,
      sentimentCategory: 'NEUTRAL',
      volatility: 0.2,
      trend: 'STABLE',
      confidence: 0.1,
      timestamp: Date.now(),
      source: 'EnhancedSentimentAnalysisService'
    }
  }

  /**
   * Health check for the service
   * @returns Promise<boolean>
   */
  async healthCheck(): Promise<boolean> {
    try {
      await this.getSentimentSignal('AAPL')
      return true
    } catch (error) {
      this.errorHandler.handleError('healthCheck', error)
      return false
    }
  }
}

// Export singleton instance
export const enhancedSentimentAnalysisService = new EnhancedSentimentAnalysisService()
export default enhancedSentimentAnalysisService