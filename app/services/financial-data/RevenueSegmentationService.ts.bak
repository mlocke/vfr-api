/**
 * Revenue Segmentation Service
 * Analyzes revenue by geographic and product segments
 * Provides insights into revenue diversification and growth opportunities
 */

import { RevenueSegmentation, GeographicRevenue, ProductRevenue, SegmentAnalysis } from './types'
import { createServiceErrorHandler } from '../error-handling'
import SecurityValidator from '../security/SecurityValidator'
import { redisCache } from '../cache/RedisCache'

export class RevenueSegmentationService {
  private readonly errorHandler: ReturnType<typeof createServiceErrorHandler>
  private readonly cacheTTL = 3600000 // 1 hour cache for segmentation data

  constructor() {
    this.errorHandler = createServiceErrorHandler('RevenueSegmentationService')
  }

  /**
   * Get revenue segmentation data for a symbol and period
   * @param symbol Stock symbol
   * @param period Period identifier (e.g., 'Q3-2024', '2024')
   * @returns Promise<RevenueSegmentation | null>
   */
  async getRevenueSegmentation(symbol: string, period: string = 'TTM'): Promise<RevenueSegmentation | null> {
    try {
      SecurityValidator.validateSymbol(symbol)

      const cacheKey = `revenue-segmentation:${symbol.toUpperCase()}:${period}`
      const cachedData = await redisCache.get<RevenueSegmentation>(cacheKey)

      if (cachedData) {
        return cachedData
      }

      // Mock revenue segmentation data
      const mockData = this.generateMockSegmentation(symbol, period)

      await redisCache.set(cacheKey, mockData, this.cacheTTL)
      return mockData

    } catch (error) {
      this.errorHandler.handleError('getRevenueSegmentation', error, { symbol, period })
      return null
    }
  }

  /**
   * Get segment analysis with insights and risks
   * @param symbol Stock symbol
   * @returns Promise<SegmentAnalysis>
   */
  async getSegmentAnalysis(symbol: string): Promise<SegmentAnalysis> {
    try {
      SecurityValidator.validateSymbol(symbol)

      const cacheKey = `segment-analysis:${symbol.toUpperCase()}`
      const cachedData = await redisCache.get<SegmentAnalysis>(cacheKey)

      if (cachedData) {
        return cachedData
      }

      const segmentation = await this.getRevenueSegmentation(symbol)

      if (!segmentation) {
        throw new Error(`No segmentation data available for ${symbol}`)
      }

      const analysis = this.analyzeSegmentation(segmentation)

      await redisCache.set(cacheKey, analysis, this.cacheTTL)
      return analysis

    } catch (error) {
      throw this.errorHandler.handleError('getSegmentAnalysis', error, { symbol })
    }
  }

  /**
   * Get geographic revenue breakdown
   * @param symbol Stock symbol
   * @param period Period identifier
   * @returns Promise<GeographicRevenue[]>
   */
  async getGeographicRevenue(symbol: string, period: string = 'TTM'): Promise<GeographicRevenue[]> {
    try {
      SecurityValidator.validateSymbol(symbol)

      const segmentation = await this.getRevenueSegmentation(symbol, period)
      return segmentation?.geographicSegments || []

    } catch (error) {
      throw this.errorHandler.handleError('getGeographicRevenue', error, { symbol, period })
    }
  }

  /**
   * Get product revenue breakdown
   * @param symbol Stock symbol
   * @param period Period identifier
   * @returns Promise<ProductRevenue[]>
   */
  async getProductRevenue(symbol: string, period: string = 'TTM'): Promise<ProductRevenue[]> {
    try {
      SecurityValidator.validateSymbol(symbol)

      const segmentation = await this.getRevenueSegmentation(symbol, period)
      return segmentation?.productSegments || []

    } catch (error) {
      throw this.errorHandler.handleError('getProductRevenue', error, { symbol, period })
    }
  }

  /**
   * Get revenue segmentation for multiple symbols
   * @param symbols Array of stock symbols
   * @returns Promise<{ symbol: string; segmentation: RevenueSegmentation | null }[]>
   */
  async getRevenueSegmentationBatch(symbols: string[]): Promise<{ symbol: string; segmentation: RevenueSegmentation | null }[]> {
    try {
      if (!symbols || symbols.length === 0) {
        throw new Error('Symbols array is required')
      }

      const results = await Promise.allSettled(
        symbols.map(async symbol => ({
          symbol: symbol.toUpperCase(),
          segmentation: await this.getRevenueSegmentation(symbol)
        }))
      )

      return results
        .filter((result): result is PromiseFulfilledResult<{ symbol: string; segmentation: RevenueSegmentation | null }> =>
          result.status === 'fulfilled'
        )
        .map(result => result.value)

    } catch (error) {
      throw this.errorHandler.handleError('getRevenueSegmentationBatch', error, { symbols })
    }
  }

  /**
   * Find companies with similar revenue patterns
   * @param symbol Reference stock symbol
   * @param threshold Similarity threshold (0-1)
   * @returns Promise<string[]>
   */
  async findSimilarRevenuePatterns(symbol: string, threshold: number = 0.8): Promise<string[]> {
    try {
      SecurityValidator.validateSymbol(symbol)

      const referenceAnalysis = await this.getSegmentAnalysis(symbol)

      // Mock similar companies - would implement actual pattern matching
      const similarCompanies = ['MSFT', 'GOOGL', 'META', 'AMZN', 'NFLX']
        .filter(s => s !== symbol.toUpperCase())
        .slice(0, 3)

      return similarCompanies

    } catch (error) {
      throw this.errorHandler.handleError('findSimilarRevenuePatterns', error, { symbol, threshold })
    }
  }

  /**
   * Generate mock revenue segmentation data
   * @private
   */
  private generateMockSegmentation(symbol: string, period: string): RevenueSegmentation {
    const hash = symbol.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0)
    const totalRevenue = (hash % 1000 + 500) * 1000000 // $500M-$1.5B base

    // Generate geographic segments
    const geographicSegments: GeographicRevenue[] = [
      {
        region: 'North America',
        revenue: totalRevenue * (0.35 + Math.random() * 0.15), // 35-50%
        percentage: 0,
        growthRate: -5 + Math.random() * 20, // -5% to +15%
        margin: 15 + Math.random() * 10, // 15-25%
        currency: 'USD'
      },
      {
        region: 'Europe',
        revenue: totalRevenue * (0.15 + Math.random() * 0.15), // 15-30%
        percentage: 0,
        growthRate: -5 + Math.random() * 25, // -5% to +20%
        margin: 12 + Math.random() * 8, // 12-20%
        currency: 'EUR'
      },
      {
        region: 'Asia Pacific',
        revenue: totalRevenue * (0.10 + Math.random() * 0.20), // 10-30%
        percentage: 0,
        growthRate: 5 + Math.random() * 25, // 5% to +30%
        margin: 18 + Math.random() * 7, // 18-25%
        currency: 'USD'
      },
      {
        region: 'Other',
        revenue: 0,
        percentage: 0,
        growthRate: Math.random() * 20 - 10, // -10% to +10%
        margin: 10 + Math.random() * 15, // 10-25%
        currency: 'USD'
      }
    ]

    // Calculate remaining revenue for "Other"
    const allocatedRevenue = geographicSegments.slice(0, 3).reduce((sum, seg) => sum + seg.revenue, 0)
    geographicSegments[3].revenue = totalRevenue - allocatedRevenue

    // Calculate percentages
    geographicSegments.forEach(seg => {
      seg.percentage = (seg.revenue / totalRevenue) * 100
    })

    // Generate product segments
    const productCategories = this.getProductCategories(symbol)
    const productSegments: ProductRevenue[] = productCategories.map((category, index) => {
      const basePercentage = index === 0 ? 0.4 : 0.6 / (productCategories.length - 1)
      const percentage = basePercentage + (Math.random() - 0.5) * 0.2
      const revenue = totalRevenue * Math.max(0.05, percentage)

      return {
        product: category.name,
        revenue,
        percentage: (revenue / totalRevenue) * 100,
        growthRate: category.growth + (Math.random() - 0.5) * 10,
        margin: category.margin + (Math.random() - 0.5) * 5,
        category: category.type
      }
    })

    // Normalize product percentages
    const totalProductRevenue = productSegments.reduce((sum, seg) => sum + seg.revenue, 0)
    productSegments.forEach(seg => {
      seg.revenue = (seg.revenue / totalProductRevenue) * totalRevenue
      seg.percentage = (seg.revenue / totalRevenue) * 100
    })

    const segmentAnalysis = this.analyzeSegmentation({
      symbol: symbol.toUpperCase(),
      period,
      totalRevenue,
      geographicSegments,
      productSegments,
      segmentAnalysis: {} as SegmentAnalysis,
      timestamp: Date.now(),
      source: 'RevenueSegmentationService'
    })

    return {
      symbol: symbol.toUpperCase(),
      period,
      totalRevenue,
      geographicSegments,
      productSegments,
      segmentAnalysis,
      timestamp: Date.now(),
      source: 'RevenueSegmentationService'
    }
  }

  /**
   * Get product categories based on symbol
   * @private
   */
  private getProductCategories(symbol: string): Array<{ name: string; type: string; growth: number; margin: number }> {
    // Mock product categories - would be based on actual company data
    const techCategories = [
      { name: 'Cloud Services', type: 'Technology', growth: 15, margin: 25 },
      { name: 'Software Licenses', type: 'Technology', growth: 8, margin: 35 },
      { name: 'Hardware', type: 'Technology', growth: 5, margin: 15 },
      { name: 'Professional Services', type: 'Services', growth: 12, margin: 20 }
    ]

    const retailCategories = [
      { name: 'Consumer Electronics', type: 'Retail', growth: 10, margin: 12 },
      { name: 'Home & Garden', type: 'Retail', growth: 6, margin: 15 },
      { name: 'Fashion & Apparel', type: 'Retail', growth: 8, margin: 18 },
      { name: 'Books & Media', type: 'Retail', growth: 3, margin: 10 }
    ]

    // Simple heuristic based on symbol
    const isTech = ['AAPL', 'MSFT', 'GOOGL', 'META', 'AMZN', 'NFLX'].includes(symbol.toUpperCase())
    return isTech ? techCategories : retailCategories
  }

  /**
   * Analyze revenue segmentation
   * @private
   */
  private analyzeSegmentation(segmentation: RevenueSegmentation): SegmentAnalysis {
    const { geographicSegments, productSegments } = segmentation

    // Calculate diversification score (0-10, higher is more diversified)
    const geoHerfindahl = geographicSegments.reduce((sum, seg) => sum + Math.pow(seg.percentage / 100, 2), 0)
    const productHerfindahl = productSegments.reduce((sum, seg) => sum + Math.pow(seg.percentage / 100, 2), 0)
    const diversificationScore = Math.max(0, 10 - (geoHerfindahl + productHerfindahl) * 5)

    // Assess geographic risk
    const highRiskRegions = ['Asia Pacific', 'Other']
    const highRiskExposure = geographicSegments
      .filter(seg => highRiskRegions.includes(seg.region))
      .reduce((sum, seg) => sum + seg.percentage, 0)

    const geographicRisk: 'LOW' | 'MEDIUM' | 'HIGH' =
      highRiskExposure > 50 ? 'HIGH' :
      highRiskExposure > 30 ? 'MEDIUM' : 'LOW'

    // Calculate product concentration (0-1, higher is more concentrated)
    const maxProductPercentage = Math.max(...productSegments.map(seg => seg.percentage))
    const productConcentration = maxProductPercentage / 100

    // Identify growth segments
    const growthSegments = [
      ...geographicSegments.filter(seg => seg.growthRate > 10).map(seg => seg.region),
      ...productSegments.filter(seg => seg.growthRate > 10).map(seg => seg.product)
    ]

    // Identify risk segments
    const riskSegments = [
      ...geographicSegments.filter(seg => seg.growthRate < -2).map(seg => seg.region),
      ...productSegments.filter(seg => seg.growthRate < -2).map(seg => seg.product)
    ]

    // Generate opportunities
    const opportunities: string[] = []
    if (growthSegments.length > 0) {
      opportunities.push(`Capitalize on growth in: ${growthSegments.slice(0, 2).join(', ')}`)
    }
    if (diversificationScore < 6) {
      opportunities.push('Diversify revenue base to reduce concentration risk')
    }

    // Generate key insights
    const keyInsights: string[] = [
      `Revenue is ${diversificationScore > 7 ? 'well-diversified' : diversificationScore > 4 ? 'moderately diversified' : 'concentrated'}`,
      `Geographic risk level: ${geographicRisk}`,
      `Product concentration: ${(productConcentration * 100).toFixed(1)}%`
    ]

    if (growthSegments.length > 0) {
      keyInsights.push(`Strong growth in: ${growthSegments.join(', ')}`)
    }

    return {
      symbol: segmentation.symbol,
      diversificationScore,
      geographicRisk,
      productConcentration,
      growthSegments,
      riskSegments,
      opportunities,
      keyInsights,
      confidence: 0.8
    }
  }

  /**
   * Health check for the service
   * @returns Promise<boolean>
   */
  async healthCheck(): Promise<boolean> {
    try {
      await this.getRevenueSegmentation('AAPL')
      return true
    } catch (error) {
      this.errorHandler.handleError('healthCheck', error)
      return false
    }
  }
}

// Export singleton instance
export const revenueSegmentationService = new RevenueSegmentationService()
export default revenueSegmentationService