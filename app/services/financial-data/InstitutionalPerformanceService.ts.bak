/**
 * Institutional Performance Service
 * Performance benchmarking and analysis for institutional holdings
 * Tracks institutional performance metrics and benchmark comparisons
 */

import { InstitutionalPerformance, PerformanceMetric, BenchmarkComparison } from './types'
import { createServiceErrorHandler } from '../error-handling'
import SecurityValidator from '../security/SecurityValidator'
import { redisCache } from '../cache/RedisCache'

export class InstitutionalPerformanceService {
  private readonly errorHandler: ReturnType<typeof createServiceErrorHandler>
  private readonly cacheTTL = 3600000 // 1 hour cache for performance data

  constructor() {
    this.errorHandler = createServiceErrorHandler('InstitutionalPerformanceService')
  }

  /**
   * Get institutional performance analysis for a symbol
   * @param symbol Stock symbol
   * @param institution Institution name (optional)
   * @returns Promise<InstitutionalPerformance[]>
   */
  async getInstitutionalPerformance(symbol: string, institution?: string): Promise<InstitutionalPerformance[]> {
    try {
      SecurityValidator.validateSymbol(symbol)

      const cacheKey = `institutional-performance:${symbol.toUpperCase()}:${institution || 'all'}`
      const cachedData = await redisCache.get<InstitutionalPerformance[]>(cacheKey)

      if (cachedData) {
        return cachedData
      }

      // Mock institutional performance data
      const institutions = institution ? [institution] : ['Vanguard', 'BlackRock', 'State Street', 'Fidelity']

      const performances: InstitutionalPerformance[] = institutions.map(inst => ({
        symbol: symbol.toUpperCase(),
        institution: inst,
        performanceMetrics: this.generatePerformanceMetrics(symbol, inst),
        benchmarkComparison: this.generateBenchmarkComparison(symbol, inst),
        riskMetrics: {
          volatility: Math.random() * 0.3 + 0.1, // 0.1-0.4
          sharpeRatio: Math.random() * 2 + 0.5,   // 0.5-2.5
          maxDrawdown: Math.random() * 0.2 + 0.05, // 5-25%
          beta: Math.random() * 0.6 + 0.7        // 0.7-1.3
        },
        holdingPeriod: this.generateHoldingPeriod(),
        confidence: 0.8,
        timestamp: Date.now(),
        source: 'InstitutionalPerformanceService'
      }))

      await redisCache.set(cacheKey, performances, this.cacheTTL)
      return performances

    } catch (error) {
      throw this.errorHandler.handleError('getInstitutionalPerformance', error, { symbol, institution })
    }
  }

  /**
   * Get benchmark comparison for institutional holdings
   * @param symbol Stock symbol
   * @param institution Institution name
   * @param period Time period for comparison
   * @returns Promise<BenchmarkComparison>
   */
  async getBenchmarkComparison(symbol: string, institution: string, period: string = '1Y'): Promise<BenchmarkComparison> {
    try {
      SecurityValidator.validateSymbol(symbol)

      const cacheKey = `benchmark-comparison:${symbol.toUpperCase()}:${institution}:${period}`
      const cachedData = await redisCache.get<BenchmarkComparison>(cacheKey)

      if (cachedData) {
        return cachedData
      }

      const comparison = this.generateBenchmarkComparison(symbol, institution, period)

      await redisCache.set(cacheKey, comparison, this.cacheTTL)
      return comparison

    } catch (error) {
      throw this.errorHandler.handleError('getBenchmarkComparison', error, { symbol, institution, period })
    }
  }

  /**
   * Get top performing institutions for a symbol
   * @param symbol Stock symbol
   * @param limit Number of top performers to return
   * @returns Promise<InstitutionalPerformance[]>
   */
  async getTopPerformers(symbol: string, limit: number = 5): Promise<InstitutionalPerformance[]> {
    try {
      SecurityValidator.validateSymbol(symbol)

      const performances = await this.getInstitutionalPerformance(symbol)

      // Sort by alpha (outperformance)
      const sorted = performances.sort((a, b) =>
        b.benchmarkComparison.alpha - a.benchmarkComparison.alpha
      )

      return sorted.slice(0, limit)

    } catch (error) {
      throw this.errorHandler.handleError('getTopPerformers', error, { symbol, limit })
    }
  }

  /**
   * Get institutional performance for multiple symbols
   * @param symbols Array of stock symbols
   * @returns Promise<{ symbol: string; performances: InstitutionalPerformance[] }[]>
   */
  async getInstitutionalPerformanceBatch(symbols: string[]): Promise<{ symbol: string; performances: InstitutionalPerformance[] }[]> {
    try {
      if (!symbols || symbols.length === 0) {
        throw new Error('Symbols array is required')
      }

      const results = await Promise.allSettled(
        symbols.map(async symbol => ({
          symbol: symbol.toUpperCase(),
          performances: await this.getInstitutionalPerformance(symbol)
        }))
      )

      return results
        .filter((result): result is PromiseFulfilledResult<{ symbol: string; performances: InstitutionalPerformance[] }> =>
          result.status === 'fulfilled'
        )
        .map(result => result.value)

    } catch (error) {
      throw this.errorHandler.handleError('getInstitutionalPerformanceBatch', error, { symbols })
    }
  }

  /**
   * Analyze performance trends across institutions
   * @param symbol Stock symbol
   * @returns Promise<{ trend: string; analysis: string; performers: string[] }>
   */
  async analyzePerformanceTrends(symbol: string): Promise<{ trend: string; analysis: string; performers: string[] }> {
    try {
      SecurityValidator.validateSymbol(symbol)

      const performances = await this.getInstitutionalPerformance(symbol)

      // Calculate average alpha
      const avgAlpha = performances.reduce((sum, p) => sum + p.benchmarkComparison.alpha, 0) / performances.length

      const trend = avgAlpha > 2 ? 'OUTPERFORMING' : avgAlpha < -2 ? 'UNDERPERFORMING' : 'MIXED'

      const topPerformers = performances
        .filter(p => p.benchmarkComparison.alpha > 0)
        .sort((a, b) => b.benchmarkComparison.alpha - a.benchmarkComparison.alpha)
        .slice(0, 3)
        .map(p => p.institution)

      const analysis = `Institutional performance for ${symbol.toUpperCase()} shows ${trend.toLowerCase()} results with average alpha of ${avgAlpha.toFixed(2)}%. ${topPerformers.length > 0 ? `Top performers: ${topPerformers.join(', ')}.` : ''}`

      return {
        trend,
        analysis,
        performers: topPerformers
      }

    } catch (error) {
      throw this.errorHandler.handleError('analyzePerformanceTrends', error, { symbol })
    }
  }

  /**
   * Generate mock performance metrics
   * @private
   */
  private generatePerformanceMetrics(symbol: string, institution: string): PerformanceMetric[] {
    const hash = (symbol + institution).split('').reduce((acc, char) => acc + char.charCodeAt(0), 0)
    const baseReturn = Math.sin(hash / 100) * 10 // -10% to +10%

    return [
      {
        metric: 'Total Return',
        value: baseReturn + (Math.random() * 10 - 5),
        percentile: Math.random() * 100,
        period: '1Y',
        benchmark: baseReturn * 0.8
      },
      {
        metric: 'Risk-Adjusted Return',
        value: baseReturn * 1.2,
        percentile: Math.random() * 100,
        period: '1Y',
        benchmark: baseReturn
      },
      {
        metric: 'Information Ratio',
        value: Math.random() * 2 - 0.5, // -0.5 to 1.5
        percentile: Math.random() * 100,
        period: '1Y'
      }
    ]
  }

  /**
   * Generate mock benchmark comparison
   * @private
   */
  private generateBenchmarkComparison(symbol: string, institution: string, period: string = '1Y'): BenchmarkComparison {
    const hash = (symbol + institution).split('').reduce((acc, char) => acc + char.charCodeAt(0), 0)

    const benchmarkReturn = Math.sin(hash / 150) * 15 // -15% to +15%
    const institutionalReturn = benchmarkReturn + (Math.random() * 10 - 5) // Add some variance

    return {
      symbol: symbol.toUpperCase(),
      benchmarkReturn,
      institutionalReturn,
      alpha: institutionalReturn - benchmarkReturn,
      trackingError: Math.random() * 5 + 1, // 1-6%
      informationRatio: Math.random() * 1.5 - 0.5, // -0.5 to 1.0
      outperformance: institutionalReturn - benchmarkReturn,
      period
    }
  }

  /**
   * Generate mock holding period
   * @private
   */
  private generateHoldingPeriod(): string {
    const periods = ['3M', '6M', '1Y', '2Y', '3Y', '5Y+']
    return periods[Math.floor(Math.random() * periods.length)]
  }

  /**
   * Health check for the service
   * @returns Promise<boolean>
   */
  async healthCheck(): Promise<boolean> {
    try {
      await this.getInstitutionalPerformance('AAPL')
      return true
    } catch (error) {
      this.errorHandler.handleError('healthCheck', error)
      return false
    }
  }
}

// Export singleton instance
export const institutionalPerformanceService = new InstitutionalPerformanceService()
export default institutionalPerformanceService