/**
 * Sector Rotation Service
 * Analyzes sector rotation patterns and momentum
 * Identifies leading and lagging sectors in market cycles
 */

import { SectorRotation, SectorPerformance, SectorMomentum, RotationPattern } from './types'
import { createServiceErrorHandler } from '../error-handling'
import SecurityValidator from '../security/SecurityValidator'
import { redisCache } from '../cache/RedisCache'

export class SectorRotationService {
  private readonly errorHandler: ReturnType<typeof createServiceErrorHandler>
  private readonly cacheTTL = 1800000 // 30 minutes cache for sector data

  private readonly sectors = [
    'Technology',
    'Healthcare',
    'Financials',
    'Consumer Discretionary',
    'Communication Services',
    'Industrials',
    'Consumer Staples',
    'Energy',
    'Utilities',
    'Real Estate',
    'Materials'
  ]

  constructor() {
    this.errorHandler = createServiceErrorHandler('SectorRotationService')
  }

  /**
   * Get current sector rotation analysis
   * @param period Analysis period (e.g., '3M', '6M', '1Y')
   * @returns Promise<SectorRotation>
   */
  async getSectorRotation(period: string = '3M'): Promise<SectorRotation> {
    try {
      const cacheKey = `sector-rotation:${period}`
      const cachedData = await redisCache.get<SectorRotation>(cacheKey)

      if (cachedData) {
        return cachedData
      }

      // Mock sector rotation analysis
      const sectorPerformances = await this.getAllSectorPerformances()

      // Sort by recent performance to identify leaders/laggards
      const sortedSectors = sectorPerformances.sort((a, b) => b.momentum.momentum - a.momentum.momentum)

      const leadingSectors = sortedSectors.slice(0, 3).map(s => s.sector)
      const laggingSectors = sortedSectors.slice(-3).map(s => s.sector)

      const rotation: SectorRotation = {
        period,
        rotationPhase: this.determineMarketPhase(sectorPerformances),
        leadingSectors,
        laggingSectors,
        rotationStrength: this.calculateRotationStrength(sectorPerformances),
        confidence: 0.8,
        timestamp: Date.now(),
        source: 'SectorRotationService'
      }

      await redisCache.set(cacheKey, rotation, this.cacheTTL)
      return rotation

    } catch (error) {
      throw this.errorHandler.handleError('getSectorRotation', error, { period })
    }
  }

  /**
   * Get performance data for a specific sector
   * @param sector Sector name
   * @returns Promise<SectorPerformance>
   */
  async getSectorPerformance(sector: string): Promise<SectorPerformance> {
    try {
      const cacheKey = `sector-performance:${sector}`
      const cachedData = await redisCache.get<SectorPerformance>(cacheKey)

      if (cachedData) {
        return cachedData
      }

      const performance = this.generateMockSectorPerformance(sector)

      await redisCache.set(cacheKey, performance, this.cacheTTL)
      return performance

    } catch (error) {
      throw this.errorHandler.handleError('getSectorPerformance', error, { sector })
    }
  }

  /**
   * Get sector momentum analysis
   * @param sector Sector name
   * @returns Promise<SectorMomentum>
   */
  async getSectorMomentum(sector: string): Promise<SectorMomentum> {
    try {
      const cacheKey = `sector-momentum:${sector}`
      const cachedData = await redisCache.get<SectorMomentum>(cacheKey)

      if (cachedData) {
        return cachedData
      }

      const momentum = this.generateMockSectorMomentum(sector)

      await redisCache.set(cacheKey, momentum, this.cacheTTL)
      return momentum

    } catch (error) {
      throw this.errorHandler.handleError('getSectorMomentum', error, { sector })
    }
  }

  /**
   * Get all sector performances
   * @returns Promise<SectorPerformance[]>
   */
  async getAllSectorPerformances(): Promise<SectorPerformance[]> {
    try {
      const cacheKey = 'all-sector-performances'
      const cachedData = await redisCache.get<SectorPerformance[]>(cacheKey)

      if (cachedData) {
        return cachedData
      }

      const performances = await Promise.all(
        this.sectors.map(sector => this.getSectorPerformance(sector))
      )

      await redisCache.set(cacheKey, performances, this.cacheTTL)
      return performances

    } catch (error) {
      throw this.errorHandler.handleError('getAllSectorPerformances', error)
    }
  }

  /**
   * Identify sector rotation patterns
   * @param period Time period for analysis
   * @returns Promise<RotationPattern[]>
   */
  async getRotationPatterns(period: string = '1Y'): Promise<RotationPattern[]> {
    try {
      const cacheKey = `rotation-patterns:${period}`
      const cachedData = await redisCache.get<RotationPattern[]>(cacheKey)

      if (cachedData) {
        return cachedData
      }

      const patterns = this.generateMockRotationPatterns(period)

      await redisCache.set(cacheKey, patterns, this.cacheTTL)
      return patterns

    } catch (error) {
      throw this.errorHandler.handleError('getRotationPatterns', error, { period })
    }
  }

  /**
   * Get sector recommendations based on rotation analysis
   * @returns Promise<{ buy: string[]; sell: string[]; hold: string[] }>
   */
  async getSectorRecommendations(): Promise<{ buy: string[]; sell: string[]; hold: string[] }> {
    try {
      const cacheKey = 'sector-recommendations'
      const cachedData = await redisCache.get<{ buy: string[]; sell: string[]; hold: string[] }>(cacheKey)

      if (cachedData) {
        return cachedData
      }

      const rotation = await this.getSectorRotation()
      const performances = await this.getAllSectorPerformances()

      // Generate recommendations based on momentum and rotation phase
      const strongMomentumSectors = performances
        .filter(p => p.momentum.momentum > 5)
        .map(p => p.sector)

      const weakMomentumSectors = performances
        .filter(p => p.momentum.momentum < -3)
        .map(p => p.sector)

      const recommendations = {
        buy: rotation.leadingSectors.filter(s => strongMomentumSectors.includes(s)),
        sell: rotation.laggingSectors.filter(s => weakMomentumSectors.includes(s)),
        hold: this.sectors.filter(s =>
          !rotation.leadingSectors.includes(s) &&
          !rotation.laggingSectors.includes(s)
        )
      }

      await redisCache.set(cacheKey, recommendations, this.cacheTTL)
      return recommendations

    } catch (error) {
      throw this.errorHandler.handleError('getSectorRecommendations', error)
    }
  }

  /**
   * Find best sector ETFs based on rotation analysis
   * @param limit Number of ETFs to return
   * @returns Promise<{ sector: string; etf: string; score: number }[]>
   */
  async getBestSectorETFs(limit: number = 5): Promise<{ sector: string; etf: string; score: number }[]> {
    try {
      const recommendations = await this.getSectorRecommendations()
      const performances = await this.getAllSectorPerformances()

      // Mock ETF mapping
      const sectorETFs: { [sector: string]: string } = {
        'Technology': 'XLK',
        'Healthcare': 'XLV',
        'Financials': 'XLF',
        'Consumer Discretionary': 'XLY',
        'Communication Services': 'XLC',
        'Industrials': 'XLI',
        'Consumer Staples': 'XLP',
        'Energy': 'XLE',
        'Utilities': 'XLU',
        'Real Estate': 'XLRE',
        'Materials': 'XLB'
      }

      const etfRecommendations = recommendations.buy
        .map(sector => {
          const performance = performances.find(p => p.sector === sector)
          return {
            sector,
            etf: sectorETFs[sector] || 'N/A',
            score: performance ? performance.momentum.momentum : 0
          }
        })
        .sort((a, b) => b.score - a.score)
        .slice(0, limit)

      return etfRecommendations

    } catch (error) {
      throw this.errorHandler.handleError('getBestSectorETFs', error, { limit })
    }
  }

  /**
   * Generate mock sector performance
   * @private
   */
  private generateMockSectorPerformance(sector: string): SectorPerformance {
    // Generate consistent data based on sector hash
    const hash = sector.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0)
    const seed = hash % 100

    const momentum = this.generateMockSectorMomentum(sector)

    // Base returns on sector characteristics
    const volatilityMultiplier = this.getSectorVolatility(sector)
    const baseReturn = (Math.sin(seed / 50) * 15) * volatilityMultiplier // -15% to +15%

    return {
      sector,
      returns: {
        oneWeek: baseReturn * 0.1 + (Math.random() - 0.5) * 2,
        oneMonth: baseReturn * 0.3 + (Math.random() - 0.5) * 3,
        threeMonths: baseReturn * 0.7 + (Math.random() - 0.5) * 5,
        oneYear: baseReturn + (Math.random() - 0.5) * 8
      },
      momentum,
      relativeStrength: baseReturn - 8, // vs S&P 500 baseline
      volatility: 15 + volatilityMultiplier * 5,
      trend: momentum.momentum > 2 ? 'OUTPERFORMING' :
             momentum.momentum < -2 ? 'UNDERPERFORMING' : 'INLINE',
      timestamp: Date.now()
    }
  }

  /**
   * Generate mock sector momentum
   * @private
   */
  private generateMockSectorMomentum(sector: string): SectorMomentum {
    const hash = sector.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0)
    const seed = hash % 100

    const momentum = Math.sin(seed / 30) * 8 // -8 to +8
    const acceleration = Math.cos(seed / 40) * 3 // -3 to +3

    return {
      sector,
      momentum,
      acceleration,
      volume: 85 + Math.random() * 30, // 85-115% of average
      breadth: Math.max(20, Math.min(80, 50 + momentum * 3)), // 20-80%
      technicalRating: this.getTechnicalRating(momentum)
    }
  }

  /**
   * Get sector-specific volatility multiplier
   * @private
   */
  private getSectorVolatility(sector: string): number {
    const volatilityMap: { [sector: string]: number } = {
      'Technology': 1.3,
      'Healthcare': 1.0,
      'Financials': 1.2,
      'Consumer Discretionary': 1.1,
      'Communication Services': 1.2,
      'Industrials': 1.0,
      'Consumer Staples': 0.7,
      'Energy': 1.5,
      'Utilities': 0.6,
      'Real Estate': 1.1,
      'Materials': 1.2
    }

    return volatilityMap[sector] || 1.0
  }

  /**
   * Get technical rating based on momentum
   * @private
   */
  private getTechnicalRating(momentum: number): 'STRONG_BUY' | 'BUY' | 'HOLD' | 'SELL' | 'STRONG_SELL' {
    if (momentum > 6) return 'STRONG_BUY'
    if (momentum > 3) return 'BUY'
    if (momentum > -3) return 'HOLD'
    if (momentum > -6) return 'SELL'
    return 'STRONG_SELL'
  }

  /**
   * Determine market cycle phase
   * @private
   */
  private determineMarketPhase(performances: SectorPerformance[]): 'EARLY_CYCLE' | 'MID_CYCLE' | 'LATE_CYCLE' | 'RECESSION' {
    const techPerformance = performances.find(p => p.sector === 'Technology')?.momentum.momentum || 0
    const financialsPerformance = performances.find(p => p.sector === 'Financials')?.momentum.momentum || 0
    const utilitiesPerformance = performances.find(p => p.sector === 'Utilities')?.momentum.momentum || 0

    // Simple heuristic for cycle phase
    if (financialsPerformance > 3 && techPerformance > 2) return 'EARLY_CYCLE'
    if (techPerformance > 4) return 'MID_CYCLE'
    if (utilitiesPerformance > techPerformance) return 'LATE_CYCLE'
    return 'RECESSION'
  }

  /**
   * Calculate rotation strength
   * @private
   */
  private calculateRotationStrength(performances: SectorPerformance[]): number {
    const momentumValues = performances.map(p => p.momentum.momentum)
    const maxMomentum = Math.max(...momentumValues)
    const minMomentum = Math.min(...momentumValues)

    // Rotation strength based on momentum spread
    return Math.min(10, Math.max(0, (maxMomentum - minMomentum) / 2))
  }

  /**
   * Generate mock rotation patterns
   * @private
   */
  private generateMockRotationPatterns(period: string): RotationPattern[] {
    const patterns: RotationPattern[] = [
      {
        fromSector: 'Utilities',
        toSector: 'Technology',
        strength: 7.5,
        duration: '3-6 months',
        confidence: 0.8,
        historicalAccuracy: 73,
        triggers: ['Interest rate changes', 'Growth expectations']
      },
      {
        fromSector: 'Energy',
        toSector: 'Healthcare',
        strength: 6.2,
        duration: '2-4 months',
        confidence: 0.7,
        historicalAccuracy: 68,
        triggers: ['Economic cycle shift', 'Defensive rotation']
      },
      {
        fromSector: 'Consumer Staples',
        toSector: 'Financials',
        strength: 5.8,
        duration: '4-8 months',
        confidence: 0.75,
        historicalAccuracy: 71,
        triggers: ['Economic recovery', 'Interest rate expectations']
      }
    ]

    return patterns
  }

  /**
   * Health check for the service
   * @returns Promise<boolean>
   */
  async healthCheck(): Promise<boolean> {
    try {
      await this.getSectorRotation()
      return true
    } catch (error) {
      this.errorHandler.handleError('healthCheck', error)
      return false
    }
  }
}

// Export singleton instance
export const sectorRotationService = new SectorRotationService()
export default sectorRotationService